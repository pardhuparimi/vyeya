name: ðŸš€ CI/CD Pipeline

on:
  push:
    branches: [main, develop, 'release/*', 'feature/*']
  pull_request:
    branches: [main, develop]

env:
  NODE_VERSION: '22'
  PNPM_VERSION: '9.15.0'

jobs:
  # Phase 1: Quality Gate - Code Quality & Unit Tests
  quality-gate:
    name: ðŸ” Quality Gate
    runs-on: ubuntu-latest
    outputs:
      should-deploy: ${{ steps.deployment-check.outputs.should-deploy }}
      environment: ${{ steps.deployment-check.outputs.environment }}
    steps:
      - uses: actions/checkout@v4
      
      - name: Setup Node.js & pnpm
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
      
      - name: Install pnpm
        run: npm install -g pnpm@${{ env.PNPM_VERSION }}
      
      - name: Cache dependencies
        uses: actions/cache@v4
        with:
          path: |
            ~/.pnpm-store
            node_modules
            packages/*/node_modules
          key: ${{ runner.os }}-pnpm-${{ hashFiles('**/pnpm-lock.yaml') }}
      
      - name: Install dependencies
        run: pnpm install --frozen-lockfile
      
      - name: ðŸ”Ž Lint Code
        run: pnpm lint
      
      - name: ðŸ” Type Check
        run: pnpm type-check
      
      - name: ðŸ§ª Unit Tests (Server)
        run: |
          cd packages/server
          pnpm test:unit -- --verbose
          echo "Unit test results:"
          find . -name "*.test.ts" -not -path "./node_modules/*" | wc -l
      
      - name: ðŸ§ª Unit Tests (App)
        run: |
          cd packages/app
          pnpm test -- --passWithNoTests --verbose
      
      - name: ðŸ“Š Coverage Report
        run: |
          cd packages/server
          pnpm test:coverage
      
      - name: ðŸ”’ Security Scan
        uses: aquasecurity/trivy-action@master
        with:
          scan-type: 'fs'
          scan-ref: '.'
          format: 'sarif'
          output: 'trivy-results.sarif'
        continue-on-error: true
      
      - name: Upload Security Results
        if: always() && hashFiles('trivy-results.sarif') != ''
        uses: github/codeql-action/upload-sarif@v3
        with:
          sarif_file: 'trivy-results.sarif'
        continue-on-error: true
      
      - name: Check Deployment Requirements
        id: deployment-check
        run: |
          echo "ðŸ” Branch: ${{ github.ref }}"
          echo "ðŸ” Event: ${{ github.event_name }}"
          
          # Only deploy from main branch, not develop
          if [[ "${{ github.ref }}" == "refs/heads/main" && "${{ github.event_name }}" == "push" ]]; then
            echo "should-deploy=true" >> $GITHUB_OUTPUT
            echo "environment=production" >> $GITHUB_OUTPUT
            echo "âœ… Will deploy to PRODUCTION"
          elif [[ "${{ github.ref }}" == "refs/heads/release/"* && "${{ github.event_name }}" == "push" ]]; then
            echo "should-deploy=true" >> $GITHUB_OUTPUT
            echo "environment=qa" >> $GITHUB_OUTPUT
            echo "âœ… Will deploy to QA"
          else
            echo "should-deploy=false" >> $GITHUB_OUTPUT
            echo "environment=none" >> $GITHUB_OUTPUT
            echo "â„¹ï¸ Develop branch - running tests only, no deployment"
          fi

  # Phase 2: Integration Tests using Docker (like our local setup)
  integration-tests:
    name: ðŸ”— Integration Tests (Docker)
    runs-on: ubuntu-latest
    needs: quality-gate
    steps:
      - uses: actions/checkout@v4
      
      - name: ðŸ³ Build CI Test Environment
        run: |
          echo "ðŸ³ Building Docker test environment..."
          docker compose -f docker-compose.ci.yml build
      
      - name: ðŸš€ Start Test Services
        run: |
          echo "ðŸš€ Starting PostgreSQL and Redis..."
          docker compose -f docker-compose.ci.yml up -d postgres-test redis-test
          
          # Wait for services to be ready
          echo "â³ Waiting for services..."
          sleep 10
          
          # Check if services are running
          docker compose -f docker-compose.ci.yml ps
      
      - name: ðŸ”— Run Integration Tests
        run: |
          echo "ðŸ”— Running HTTP integration tests in Docker environment..."
          docker compose -f docker-compose.ci.yml run --rm ci-test bash -c "
            cd /workspace &&
            pnpm install --frozen-lockfile &&
            echo 'ðŸ—ƒï¸ Initializing test database...' &&
            cd packages/server &&
            export DB_HOST='postgres-test' &&
            export DB_USER='test' &&
            export DB_PASSWORD='test' &&
            export DB_NAME='vyeya_test' &&
            export DB_PORT='5432' &&
            node src/scripts/init-db.js &&
            echo 'ðŸ§ª Starting server HTTP integration tests...' &&
            export REDIS_URL='redis://redis-test:6379' &&
            export NODE_ENV=test &&
            pnpm test:http --verbose
          "
      
      - name: ðŸ§¹ Cleanup
        if: always()
        run: docker compose -f docker-compose.ci.yml down -v

  # Phase 3: Build & Deploy (only for main and release branches)
  build-and-deploy:
    name: ðŸš€ Build & Deploy
    runs-on: ubuntu-latest
    needs: [quality-gate, integration-tests]
    if: needs.quality-gate.outputs.should-deploy == 'true'
    environment:
      name: ${{ needs.quality-gate.outputs.environment }}
      url: ${{ steps.deploy.outputs.url }}
    
    steps:
      - uses: actions/checkout@v4
      
      - name: Setup Node.js & pnpm
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
      
      - name: Install pnpm
        run: npm install -g pnpm@${{ env.PNPM_VERSION }}
      
      - name: Install dependencies
        run: pnpm install --frozen-lockfile
      
      - name: ðŸ—ï¸ Build Server
        run: |
          cd packages/server
          pnpm build
          echo "âœ… Server built successfully"
      
      - name: ðŸ—ï¸ Build App
        run: |
          cd packages/app
          # Add app build commands here when needed
          echo "âœ… App build ready"
      
      - name: ðŸ³ Build Production Docker Image
        run: |
          docker build -f packages/server/Dockerfile -t vyeya-server:${{ github.sha }} packages/server
          echo "âœ… Docker image built"
      
      - name: ðŸš€ Deploy
        id: deploy
        run: |
          ENVIRONMENT="${{ needs.quality-gate.outputs.environment }}"
          echo "ðŸš€ Deploying to ${ENVIRONMENT}"
          
          case "${ENVIRONMENT}" in
            "production")
              echo "url=https://vyeya.app" >> $GITHUB_OUTPUT
              echo "ðŸŒ Production deployment would go here"
              # Add actual AWS/production deployment
              ;;
            "qa")
              echo "url=https://qa.vyeya.app" >> $GITHUB_OUTPUT
              echo "ðŸ”§ QA deployment would go here"
              # Add QA deployment
              ;;
          esac
          
          echo "âœ… Deployment completed to ${ENVIRONMENT}"

  # Phase 4: Post-Deploy Tests (only for production)
  post-deploy-tests:
    name: ðŸŽ¯ Post-Deploy Tests
    runs-on: ubuntu-latest
    needs: [quality-gate, build-and-deploy]
    if: needs.quality-gate.outputs.environment == 'production'
    
    steps:
      - uses: actions/checkout@v4
      
      - name: ðŸ”¥ Load Tests
        run: |
          echo "ðŸ”¥ Running load tests against production"
          # Add k6 load tests here
      
      - name: ðŸŽ­ E2E Tests
        run: |
          echo "ðŸŽ­ Running E2E tests against production"
          # Add Maestro E2E tests here
